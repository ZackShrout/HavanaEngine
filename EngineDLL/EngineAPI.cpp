//******************************************
//Havana Engine API for use in Havana Editor
//******************************************
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif // !WIN32_LEAN_AND_MEAN

#include <Windows.h>
#include <atlsafe.h>
#include "Common.h"
#include "Components/Script.h"
#include "Graphics/Renderer.h"
#include "Platforms/PlatformTypes.h"
#include "Platforms/Platform.h"

using namespace havana;

namespace
{
	HMODULE game_code_dll{ nullptr };
	using _get_script_creator = havana::script::detail::script_creator(*)(size_t);
	_get_script_creator get_script_creator{ nullptr };
	using _get_script_names = LPSAFEARRAY(*)(void);
	_get_script_names get_script_names{ nullptr };
	utl::vector<graphics::RenderSurface> surfaces;
} // anonymous namespace

/// <summary>
/// Load the .dll file generated by the scripts into the Havana Editor
/// for use.
/// </summary>
/// <param name="dllPath">Path of the .dll file.</param>
/// <returns>1 if successful, 0 if not.</returns>
EDITOR_INTERFACE u32
LoadGameCodeDll(const char* dllPath)
{
	if (game_code_dll) return FALSE; // make sure it's not already loaded

	game_code_dll = LoadLibraryA(dllPath);
	assert(game_code_dll);

	get_script_creator = (_get_script_creator)GetProcAddress(game_code_dll, "get_script_creator");
	get_script_names = (_get_script_names)GetProcAddress(game_code_dll, "get_script_names");

	return (game_code_dll && get_script_creator && get_script_names) ? TRUE : FALSE;
}

/// <summary>
/// Unload the .dll file generated by the scripts from the Havana Editor
/// </summary>
/// <param name="dllPath">Path of the .dll file.</param>
/// <returns>1 if successful, 0 if not.</returns>
EDITOR_INTERFACE u32
UnloadGameCodeDll()
{
	if (!game_code_dll) return FALSE; // make sure it's already loaded
	assert(game_code_dll);
	
	int result{ FreeLibrary(game_code_dll) };
	assert(result);
	game_code_dll = nullptr;
	
	return TRUE;
}

/// <summary>
/// Get a script creator function pointer for use in the Havana Editor
/// </summary>
/// <param name="name">Name of the script to get.</param>
/// <returns>Function pointer to script.</returns>
EDITOR_INTERFACE script::detail::script_creator
GetScriptCreator(const char* name)
{
	return (game_code_dll && get_script_creator) ? get_script_creator(script::detail::string_hash()(name)) : nullptr;
}

/// <summary>
/// Get the array of script names for use in the Havana Editor
/// </summary>
/// <returns>Array of script names.</returns>
EDITOR_INTERFACE LPSAFEARRAY
GetScriptNames()
{
	return (game_code_dll && get_script_names) ? get_script_names() : nullptr;
}

/// <summary>
/// Create a window to render graphics to in the editor.
/// </summary>
/// <param name="host"> - Host for the window.</param>
/// <param name="width"> - Width of the window.</param>
/// <param name="height"> - Height of the window.</param>
/// <returns>ID of the window.</returns>
EDITOR_INTERFACE u32
CreateRenderSurface(HWND host, s32 width, s32 height)
{
	assert(host);
	platform::window_init_info info{ nullptr, host, nullptr, 0, 0, width, height };
	graphics::RenderSurface surface{ platform::create_window(&info), {} };
	assert(surface.window.is_valid());
	surfaces.emplace_back(surface);
	return (u32)(surfaces.size() - 1);
}

/// <summary>
/// Remove a graphics rendering window from the editor.
/// </summary>
/// <param name="id"> - ID of the window to remove.</param>
EDITOR_INTERFACE void
RemoveRenderSurface(u32 id)
{
	assert(id < surfaces.size());
	platform::remove_window(surfaces[id].window.get_id());
}

EDITOR_INTERFACE HWND
GetWindowHandle(u32 id)
{
	assert(id < surfaces.size());
	return (HWND)(surfaces[id].window.handle());
}

EDITOR_INTERFACE void
ResizeRenderSurface(u32 id)
{
	assert(id < surfaces.size());
	surfaces[id].window.resize(0, 0);
}